name: CI/CD

on:
  push:
    branches: ["main", "master"]
  pull_request:
    branches: ["main", "master"]
  workflow_dispatch:

permissions:
  contents: write

jobs:
  build-and-test:
    runs-on: ubuntu-latest

    steps:
      - uses: actions/checkout@v4

      - name: Setup .NET
        uses: actions/setup-dotnet@v4
        with:
          dotnet-version: 10.0.x

      - name: Restore dependencies
        run: dotnet restore AiCV.sln

      - name: Build
        run: dotnet build AiCV.sln --no-restore

      - name: Test
        run: dotnet test AiCV.sln --no-build --verbosity normal

  docker-push:
    needs: build-and-test
    runs-on: ubuntu-latest
    if: github.event_name == 'push' && (github.ref == 'refs/heads/main' || github.ref == 'refs/heads/master')

    steps:
      - uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Calculate Version
        id: version
        uses: paulhatch/semantic-version@v5.4.0
        with:
          tag_prefix: "v"
          major_pattern: "/!:|BREAKING CHANGE:/"
          minor_pattern: "/feat:/"
          version_format: "${major}.${minor}.${patch}"
          enable_prerelease_mode: false
          search_commit_body: true
          user_format_type: "csv"

      - name: Debug Version Output
        run: |
          echo "----------------------------------------"
          echo "Calculated Version: ${{ steps.version.outputs.version }}"
          echo "Major: ${{ steps.version.outputs.major }}"
          echo "Minor: ${{ steps.version.outputs.minor }}"
          echo "Patch: ${{ steps.version.outputs.patch }}"
          echo "Increment: ${{ steps.version.outputs.increment }}"
          echo "----------------------------------------"
          echo "Commit Message Debug:"
          git log -1 --format='%H %s %b'
          echo "----------------------------------------"

      - name: Log in to Docker Hub
        uses: docker/login-action@v3
        with:
          username: ${{ secrets.DOCKER_USERNAME }}
          password: ${{ secrets.DOCKER_PASSWORD }}

      - name: Build and push Docker image
        uses: docker/build-push-action@v5
        with:
          context: .
          push: true
          build-args: |
            BUILD_VERSION=${{ steps.version.outputs.version }}
          tags: |
            ${{ secrets.DOCKER_USERNAME }}/aicv:latest
            ${{ secrets.DOCKER_USERNAME }}/aicv:${{ steps.version.outputs.version }}

      - name: Tag Repository
        if: steps.version.outputs.version != ''
        run: |
          git config --global user.name "GitHub Actions"
          git config --global user.email "actions@github.com"
          git tag v${{ steps.version.outputs.version }}
          git push origin v${{ steps.version.outputs.version }}

      - name: Generate Changelog
        if: steps.version.outputs.version != ''
        run: |
          # Get previous tag
          PREV_TAG=$(git describe --tags --abbrev=0 HEAD~1 2>/dev/null || echo "")
          CURR_TAG="v${{ steps.version.outputs.version }}"

          echo "## [${{ steps.version.outputs.version }}] - $(date +%Y-%m-%d)" > /tmp/new_entry.md
          echo "" >> /tmp/new_entry.md

          # Categorize commits
          if [ -n "$PREV_TAG" ]; then
            RANGE="${PREV_TAG}..HEAD"
          else
            RANGE="HEAD"
          fi

          # Features
          FEATS=$(git log $RANGE --pretty=format:"- %s" --grep="^feat" 2>/dev/null || true)
          if [ -n "$FEATS" ]; then
            echo "### Added" >> /tmp/new_entry.md
            echo "$FEATS" | sed 's/^feat[:(]*//' >> /tmp/new_entry.md
            echo "" >> /tmp/new_entry.md
          fi

          # Fixes
          FIXES=$(git log $RANGE --pretty=format:"- %s" --grep="^fix" 2>/dev/null || true)
          if [ -n "$FIXES" ]; then
            echo "### Fixed" >> /tmp/new_entry.md
            echo "$FIXES" | sed 's/^fix[:(]*//' >> /tmp/new_entry.md
            echo "" >> /tmp/new_entry.md
          fi

          # Other changes (if no feat/fix found, list recent commits)
          if [ -z "$FEATS" ] && [ -z "$FIXES" ]; then
            echo "### Changed" >> /tmp/new_entry.md
            git log $RANGE --pretty=format:"- %s" -5 >> /tmp/new_entry.md
            echo "" >> /tmp/new_entry.md
          fi

          echo "" >> /tmp/new_entry.md

          # Insert after "## [Unreleased]" section
          sed -i '/^## \[Unreleased\]/,/^---/{/^---/r /tmp/new_entry.md
          }' CHANGELOG.md

          # Commit changelog
          git add CHANGELOG.md
          git commit -m "docs: update changelog for v${{ steps.version.outputs.version }}" || true
          git push origin HEAD:${{ github.ref_name }} || true

      - name: Create GitHub Release
        if: steps.version.outputs.version != ''
        uses: softprops/action-gh-release@v1
        with:
          tag_name: v${{ steps.version.outputs.version }}
          name: üöÄ AiCV v${{ steps.version.outputs.version }}
          body: |
            ## ‚ú® AiCV Application Generator - v${{ steps.version.outputs.version }}

            Generate **tailored CVs and cover letters** using AI while keeping your data private.

            ---

            ### üöÄ Quick Start

            ```bash
            docker pull timi74/aicv:${{ steps.version.outputs.version }}
            # or use latest
            docker pull timi74/aicv:latest
            ```

            ---

            ### üìñ Documentation

            - [Full README](https://github.com/FitimZulfiju/Ai-CV-application-generator#readme)
            - [Deployment Guide](https://github.com/FitimZulfiju/Ai-CV-application-generator/blob/master/docs/deployment.md)
            - [Docker Hub](https://hub.docker.com/r/timi74/aicv)

            ---

            **Full Changelog**: https://github.com/FitimZulfiju/Ai-CV-application-generator/blob/master/CHANGELOG.md
          draft: false
          prerelease: false
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}

  cleanup-dockerhub:
    runs-on: ubuntu-latest
    needs: docker-push
    if: github.event_name == 'push' && (github.ref == 'refs/heads/main' || github.ref == 'refs/heads/master')
    steps:
      - name: üßπ Cleanup old Docker tags and digests
        shell: bash
        run: |
          set -euo pipefail
          sudo apt-get update && sudo apt-get install -y jq curl

          DOCKER_USER="${{ secrets.DOCKER_USERNAME }}"
          DOCKER_PASS="${{ secrets.DOCKER_PASSWORD }}"
          REPO="aicv"
          NS_REPO="${DOCKER_USER}/${REPO}"
          KEEP_LAST_N=2 # Keep latest + 2 versions = 3 total

          echo "============================================"
          echo "üßπ Docker Hub Cleanup Process for ${NS_REPO}"
          echo "Strategy: Keep 'latest' + ${KEEP_LAST_N} newest versions (Total 3)"
          echo "============================================"

          AUTH_RESPONSE=$(curl -s -H "Content-Type: application/json" \
            -X POST -d "{\"username\":\"${DOCKER_USER}\",\"password\":\"${DOCKER_PASS}\"}" \
            https://hub.docker.com/v2/users/login/)
          HUB_TOKEN=$(echo "$AUTH_RESPONSE" | jq -r '.token // empty')

          if [ -z "$HUB_TOKEN" ]; then
            echo "‚ùå Failed to authenticate to Docker Hub"
            exit 1
          fi
          echo "‚úÖ Authentication successful"

          # Get a Bearer token for the Registry API (needed for manifest deletion)
          echo "üîë Getting Registry API token..."
          REGISTRY_URL="https://auth.docker.io/token?service=registry.docker.io&scope=repository:${NS_REPO}:pull,push,delete"
          REGISTRY_TOKEN=$(curl -s -u "${DOCKER_USER}:${DOCKER_PASS}" "$REGISTRY_URL" | jq -r '.token // empty')

          if [ -z "$REGISTRY_TOKEN" ]; then
             echo "‚ö†Ô∏è Failed to get Registry token. Manifest deletion (digests) might fail, but tag deletion will proceed."
          fi

          echo "üîç Fetching tags and digests..."
          TAGS_JSON=$(mktemp)
          URL="https://hub.docker.com/v2/repositories/${NS_REPO}/tags/?page_size=100&ordering=-last_updated"

          echo "[]" > "$TAGS_JSON"
          while [ -n "${URL:-}" ] && [ "$URL" != "null" ]; do
            PAGE=$(curl -s -H "Authorization: Bearer $HUB_TOKEN" "$URL")
            if [ -z "$PAGE" ] || [ "$PAGE" = "null" ]; then break; fi
            jq -s '.[0] + .[1].results' "$TAGS_JSON" <(echo "$PAGE") > "${TAGS_JSON}.tmp" && mv "${TAGS_JSON}.tmp" "$TAGS_JSON"
            URL=$(echo "$PAGE" | jq -r '.next // empty')
          done

          # Identify tags to keep
          KEEP_TAGS=$(jq -r --arg KEEP_N "$KEEP_LAST_N" '
            (map(select(.name == "latest"))) + 
            (map(select(.name != "latest")) | sort_by(.last_updated) | reverse | .[0:($KEEP_N|tonumber)]) 
            | map(.name) | unique | .[]' "$TAGS_JSON")

          echo "üîí Tags to keep:"
          echo "$KEEP_TAGS"

          # Get unique digests for kept tags
          KEEP_DIGESTS=$(jq -r --argjson keep "$(echo "$KEEP_TAGS" | jq -R . | jq -s .)" '
            .[] | select(.name as $n | $keep | index($n)) | .images[].digest' "$TAGS_JSON" | sort -u)

          echo "üîí Digests to keep (shared by kept tags):"
          echo "$KEEP_DIGESTS"

          # Get all tags
          ALL_TAGS=$(jq -r '.[].name' "$TAGS_JSON")

          # Delete tags not in KEEP_TAGS
          for t in $ALL_TAGS; do
            if ! echo "$KEEP_TAGS" | grep -qxw "$t"; then
              # Get digest of this tag
              DIGEST=$(jq -r --arg t "$t" '.[] | select(.name == $t) | .images[0].digest' "$TAGS_JSON")
              
              echo "üóëÔ∏è Deleting tag: ${t} (Digest: ${DIGEST})"
              
              # Delete the tag
              RESP=$(curl -s -w "|HTTP:%{http_code}" -o /dev/stdout \
                -X DELETE -H "Authorization: Bearer $HUB_TOKEN" \
                "https://hub.docker.com/v2/repositories/${NS_REPO}/tags/${t}/")
              CODE=${RESP##*|HTTP:}
              if [ "$CODE" = "204" ]; then
                echo "  ‚úÖ Tag deleted"
              else
                echo "  ‚ùå Failed to delete tag (HTTP $CODE)"
              fi

              # Attempt to delete the manifest if digest is not in KEEP_DIGESTS
              if [ -n "$REGISTRY_TOKEN" ] && [ -n "$DIGEST" ] && ! echo "$KEEP_DIGESTS" | grep -qxw "$DIGEST"; then
                echo "  üóëÔ∏è Deleting manifest: ${DIGEST}..."
                # Use the V2 Registry API for manifest deletion
                M_RESP=$(curl -s -w "|HTTP:%{http_code}" -o /dev/stdout \
                  -X DELETE -H "Authorization: Bearer $REGISTRY_TOKEN" \
                  -H "Accept: application/vnd.docker.distribution.manifest.v2+json" \
                  "https://registry-1.docker.io/v2/${NS_REPO}/manifests/${DIGEST}")
                M_CODE=${M_RESP##*|HTTP:}
                if [ "$M_CODE" = "202" ] || [ "$M_CODE" = "204" ]; then
                  echo "  ‚úÖ Manifest deleted"
                else
                  echo "  ‚ö†Ô∏è Failed to delete manifest (HTTP $M_CODE). It might be shared or already cleaned up."
                fi
              fi
            fi
          done

          echo "üßπ Cleanup complete."
